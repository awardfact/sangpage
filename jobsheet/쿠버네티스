쿠버네티스


<쿠버네티스란 >

컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성 있고 확장가능한 오픈소스 플랫폼이다

전통 배포 - 애플리케이션을 물리 서버에서 실행 한 서버에서 여러 애플리케이션을 동시에 실행해서 리소스 할당의 문제가 생김
해결책으로 여러 물리서버에서 각 애플리케이션을 실행하였지만 확장성이 없었다

가상화된 배포 - 전통 배포의 해결책으로 가상화를 사용하였는데  이는 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행할 수 있게한다
VM간에 애플리케이션을 격리하고 정보를 자유롭게 이용하지 못 해서 일정 수준의 보안성도 제공한다 가상화를 통해 리소스를 보다
효율적으로 활용할 수 있고 추가하거나 업데이트 할 수 있어 더 나은 확장성을 제공한다

컨테이너 개발 -  컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제를 공유한다 그래서 컨테이너는 가볍다고 여겨진다
VM과 마찬가지로 컨테이너에는 자체 파일 시스템 , CPU점유율 , 메모리 , 프로세스 공간 등이 있다 기본 인프라와 종속성을 끊었기 때문에
클라우드나 OS 배포본에 모두 이식할 수 있다 

컨테이너가 인기있는 이유 
1. 기민한 애플리케이션 생성과 배포 - VM이미지를 사용하는 것에 비해 쉽고 효율적
2. 지속적인 개발 통합 및 배포 - 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 빠르고 효율적으로 롤백할 수 있다
3. 개발과 운영 관심사 분리 - 배포 시점이 아닌 빌드/릴리스 시점에 앱 컨테이너 이미지를 만들어서 앱 인프라에서 분리된다 
4. 가시성 - os수준의 정보에서 머무르지 않고 앱 상태와 시그널을 볼 수 있다 
5. 개발, 테스팅 운영 환경에 걸친 일관성 - 랩탑에서도 클라우드와 동일하게 구동된다 
6. 클라우드 및 os 배포판 간 이식성 - 리눅스, 주요 퍼블릭 클라우드와 어디든지 구동된다 
7. 앱 중심 관리 - 가상 하드웨어 상에서 os를 실행하는 수준에서 논리적인 리소스를 사용하는 os상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다 
8. 느슨하게 커플되고 분산되고 유연하며 자유로운 마이크로 서비스 -  앱은 단일 목적 머신에서 모놀리식 스택으로 구동되지 않고 독립적인 단위로 쪼개져서 동적으로 배포 관리될 수 있다 
9. 리소스 격리 - 애플리케이션 성능을 예측할 수 있다
10 자원 사용량 - ??????

요약 
쿠버네티스는 앱을 컨테이너화 시킬 수 있고 컨테이너는 가볍고 확장성이 좋다 
쿠버네티스가 인기 있는 이유는 쉽고 안정적이고 개발과 운영 분리가 가능하고 상태를 확인하기 좋고 이식성이 좋고 앱 중심으로 관리해서 추상화 수준이 높고 
유연하고 성능이 예측 가능하다 

</쿠버네티스란>


<쿠버네티스가 필요한 이유랑 할 수 있는거>

컨테이너는 앱을 포장하고 실행하는 좋은 방법이다 프로덕션 환경에서는 앱을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다 
만약 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 하는데 이를 쿠버네티스가 해준다 

쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임웤을 제공한다 앱의 확장과 장애 조치를 처리하고 배포 패턴등을 제공한다 

쿠버네티스가 제공하는것
1. 서비스 디스커버리와 로드밸런싱 - 쿠버네티스는 DNS이름을 사용하거나 자체 IP주소를 사용하여 컨테이너를 노출할 수 있다 컨테이너에 대한 트래픽이 높으면
쿠버네티스는 네트워크 트래픽을 로드밸런싱하여 배포가 안정적으로 이루어질 수 있게 한다 
2. 스토리지 오케스트레이션 - 쿠버네티스를 사용하면 로컬 저장소 , 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 탑재할 수 있다 
3. 자동화된 롤아웃과 롤백  - 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태로 원하는 상태로 변경할 수 있다
예를들어 자동화한 후 배포용 새 컨테이너를 만들고 기존 컨테이너를 삭제하고 모든 리로스를 새 컨테이너에 적용할 수 있다 
4. 자동화된 빈 패킹 - 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다 각 컨테이너가 필요로 하는 CPU 와 메모리를
쿠버네티스에게 지시한다 쿠버네티스는 컨테이너를 노드에 맞추어 리소스를 가장 잘 사용할 수 있도록 해준다 
5. 자동화된 복구 - 쿠버네티스는 실패한 컨테이너를 다시 시작하고 컨테이너를 교체하며 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고
서비스 준비가 끝날 때까지 과정을 클라이언트에 보여주지 않는다
6. 시크릿과 구성 관리 - 쿠버네티스를 사용하면 암호 ,토큰 및 ssh키와 같은 중요한 정보를 저장하고 관리할 수 있다 컨테이너 이미지를 재구성하지 않고
스택 구성에 시크릿을 노출시키기 않고도 시크릿 및 앱 구성을 배포 및 업데이트 할 수 있다 

요약 
컨테이너는 항상 실행상태여야 하는데 쿠버네티스가 이를 도와준다  트래픽이 높으면 로드밸런싱해준다 원하는 저장소를 지원한다 상태를 바꾸고 필요하면 롤백시켜준다
컨테이너에게 자원을 분배할 수 있다 컨테이너에 문재가 생기면 복구해준다 보안관련된 정보를 관리해준다 

</쿠버네티스가 필요한 이유랑 할 수 있는거>


<쿠버네티스가 아닌 것>

쿠버네티스는 전통적인 모든것이 포함된 Platform as a Service(Paas)가 아니다 쿠버네티스는 하드웨어 수준보다는 컨테이너 수준에서 운영되기 떄문에
Paas가 일반적으로 제공하는 배포 스케일링 로드밸런싱과 같은 기능을 제공하며 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있다 
하지만 쿠버네티스는 모놀리식이 아니여서 이런 기본 솔루션이 선택적이며 추가나 제거가 용이하다 쿠버네티스는 개발자 플랫폼을 만드는 구성 요소를 제공하지만 
필요한 경우 사용자의 선택권과 유연성을 지켜준다 

쿠버네티스는
1. 지원하는 앱의 유형을 제약하지 않는다 상태 유지가 필요없는 워크로드, 상태유지가 필요한 워크로드 데이터처리를 위한 워크로드를 포함해서 극단적으로 다양한
워크로드를 지원하는것을 목표로 한다 
2. 소스 코드를 배포하지 않으며 앱을 빌드하지 않는다 지속적 통합과 전달 배포 곧 CI/CD 워크플로우는 조직의 취향에 따를 뿐만 아니라 기술적인 요구사항으로 결정된다
3. 앱 레벨의 서비스를 제공하지 않는다 앱 레벨의 서비스에는 미들웨어, 데이터 처리 프레임워크 , db , 캐시 또는 클러스터 스토리지 시스템등이 있다
이런 컴포넌트는 쿠버네티스 상에서 구동될 수 있고 쿠버네티스 상에서 구동중인 어플리케이션이  Open Service Broker와 같은 이식 가능한 메커니즘을 통해 접근할 수도 있다
4. 로깅 모니터링 또는 경보 솔루션을 포함하지 않는다 개념 증명을 위한 일부 통합이나 메트릭을 수집하고 노출하는 메커니즘을 제공한다 
5. 기본 언어/시스템을 제공하거나 요구하지 않는다 선언적 명세의 임의적인 형식을 목적으로 하는 선언적 API를 제공한다 
6. 포괄적인 머신 설정, 유지보수, 관리, 자동복구 시스템을 제공하거나 채택하지 않는다 
7. 추가로 쿠버네티스는 단순한 오케스트레이션 시스템이 아니다 쿠버네티스는 오케스트레이션의 필요성을 없애준다 오케스트레이션의 기술적인 정의는 A먼저 한 후 
B를 하고 C를 하는 것과 같이 정의된 워크플로우를 수행하는 것이다 반면에 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다 이 프로세스는
지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록 한다 A에서 C로 어떻게 갔는지는 중요하지 않다 중앙화된 제어도 필요하지 않다 이로써
보다 더 사용하기 쉬워지고 강력해지고 견고하고 회복력을 갖추게 되며 확장 가능해진다


요약 
쿠버네티스는 컨테이너 수준에서 제공되서 pass가 제공되는 기능을 제공하며 유연하게 추가 제거할 수 있다 , 앱의 유형을 제약하지 않는다 코드 배포와 앱 빌드를 하지 않는다
앱 레벨 서비스를 제공하지 않는다 로깅 모니터링 경보 솔루션을 포함하지 않는다 기본 언어/시스템을 제공하지 않는다 포괄적인 머신 설정, 유지보수 관리 자동복구를
제공하지 않는다 워크플로우를 가지지 않는다 

</쿠버네티스가 아닌 것>


<쿠버네티스 컴포넌트>

쿠버네티스를 배포하면 클러스터를 얻는다  이 클러스터는 컨테이너화된 앱을 실행하는 노드라고 하는 워커 머신의 집합이다 
모든 클러스터는 최소 한 개의 워커노드를 가진다 

워커 노드는 앱 구성요소인 파드를 호스트한다 컨트롤플레인은 워커 노드와 클러스터 내 파드를 관리한다 프로덕션 환경에서는 일반적으로 컨트롤 플레인이
여러 컴퓨터에 걸쳐 실행되고 클러스터는 일반적으로 여러 노드를 실행하므로 내결함성과 고가용성이 제공된다 


    <컨트롤 플레인 컴포넌트 >
    컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(ex)스케쥴링)을 수행하고 클러스터 이벤트를 감지하고 반응한다 

    컨트롤 플레인 컴포넌트는 클러스터 내 어떠한 머신에서든지 동작할 수 있다 그러나 간결성을 위해 구성 스크립트는 보통 동일 머신 상에서 컨트롤 플레인 컴포넌트를 구동하고
    사용자 컨테이너는 해당 머신 상에 동작시키지 않는다 

    Kube-apiserver  - API서버는 쿠버네티스 API를 노출하는 쿠버네티스 컨트롤 플레인 컴포넌트이다 API서버는 쿠버네티스 컨트롤 플레인의 프론트 엔드이다
    쿠버네티스 API서버의 주요 구현은 kube-apiserver이다 kube-apiserver는 수평으로 확장되도록 디자인되었다 즉 더 많은 인스턴스를 배포해서 확장할 수 있다
    여러 kube-apiserver인스턴스를 실행하고 인스턴스간 트래픽을 균형있게 조절할 수 있다 


    etcd
    모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성,고가용성 키-값 저장소 
    쿠버네티스 클러스터의 etcd를 뒷단의 저장소로 사용한다면 데이터를 백업하는 계획은 필수이다 

    kube-scheduler 
    노드가 배정되지 않은 새로 생성된 파드를 감지하고 실행할 노드를 선택하는 컨트롤 플레인 컴포넌트 
    스케쥴링 결정을 위해서 고려되는 요소는 리소스에 대한 개별 및 총체적 요구 사항 하드웨어/소프트웨어/정책적 제약, 어피니티 및 안티 어피니티 명세
    데이터 지역성, 워크로드 간 간섭 데드라인을 포함한다 

    kube-controller-manager 
    컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트
    논리적으로 각 컨트롤러는 분리된 프로세스이지만 복잡성을 낮추기 위해 모두 단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다

    컨트롤러는 다음을 포함한다
    1.노드 컨트롤러 - 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다 
    2.레플리케이션 컨트롤러 - 시스템의 모든 레플리케이션 컨트롤러 오브젝트에 대해 알맞은 수의 파드들을 유지시켜 주는 책임을 가진다
    3.엔드포인트 컨트롤러 - 엔드포인트 오브젝트를 채운다
    4.서비스 어카운트 & 토큰 컨트롤러 - 새로운 네임스페이스에 대한 기본 계정과 API접근 토큰을 생성한다 

    
    cloud-controller-manager
    클라우드별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트 클라우드 컨트롤러 매니저를 통해 API에 연결하고 상호작용하는
    컴포넌트 클러스터와만 상호작용하는 컴포넌트를 구분할 수 있게한다 cloud-controller-manage는 클라우드 제공자 전용 컨트롤러만 실행한다
    자신의 사내 또는 PC내부의 학습 환경에서 쿠버네티스를 실행 중인 경우 클러스터에는 클라우드 컨트롤러 매니저가 없다 

    cloud-controller-manager는 논리적으로 독립적인 여러 컨트롤 루프를 단일 프로세스로 실행하는 단일 바이너리로 결합한다 수평으로 확장해서 성능 향상할수 있다

    다음 컨트롤러들은 클라우드 제공 사업자의 의존성을 가질 수 있다
    1.노드 컨트롤러 - 노드가 응답을 멈춘 후 클라우드 상에서 삭제되었는지 판별하기 위해 클라우드 제공 사업자에게 확인하는 것 
    2. 라우트 컨트롤러 - 기본 클라우드 인프라에 경로를 구성하는 것
    3. 서비스 컨트롤러 - 클라우드 제공 사업자 로드밸런서를 생성, 업데이터 그리고 삭제하는 것 





    요약 
    컨트롤 플레인 컴포넌트는 클러스터에 대한 작업을 수행하며 어떤 머신에서든지 동작할 수 있지만 보통 동일 머신상에 모든 컨트롤 플레인 컴포넌트를 구동하고
    사용자 컨테이너는 해당 머신상에 동작시키지 않는다 API서버는 컨트롤 플레인의 프론트 엔드이며 쿠버네티스 API를 노출하는 컨트롤 플레인 컴포넌트이다
    주요 구현은 kube-apiserver이며 이것은 수평으로 확장되도록 디자인되었다  etcd는 모든 클러스터 데이터를 담는 뒷단의 저장소이다 
    kube-scheduler 노드가 배정되지 않는 파드를 노드에 분배해준다 kube-controller-manager 컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트
    단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다 컨트롤러는 노드가 다운되었을 때 대응과 파드를 유지시켜주는 기능과 엔드포인트 오브젝트를 채운는 기능과
    새로운 네임스페이스에 대한 계정과 api접근 토큰 생성 기능을 가진다  cloud-controller-manager는 api에 연결하고 상호작용하는 컴포넌트 클러스터와만 상호작용하는 컴포넌트를 구분할 수 있게한다




    </컨트롤 플레인 컴포넌트 >


    <노드 컴포넌트>
    노드 컴포넌트는 동작중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며 모든 노드 상에서 동작한다 

    kubelet 
    클러스터의 각 노드에서 실행되는 에이전트 , Kublet은 파드에서 컨테이너가 확실하게 동작하게 한다 
    다양한 메커니즘을 통해 제공된 파드 스펙의 집합을 받아서 컨테이너가 해당 파드 스펙에 따라 건강하게 동작하는 것을 확실히 한다 
    kublet은 쿠버네티스를 통해 생성되지 않는 컨테이너는 관리하지 않는다

    kube-proxy 
    kube-proxy 는 클러스터의 각 노드에서 실행되는 네트워크 프록시로 쿠버네티스 서비스 개념의 구현부이다
    kube-proxy 는 노드의 네트워크 규칙을 유지 관리한다 이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 한다
    kube-proxy 는 운영체제에 가용한 패킷 필터링 계층이 있는 경우 이를 사용한다 그렇지 않으면 kube-proxy 는 트래픽 자체를 포워드한다 

    컨테이너 런타임
    컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다 
    쿠버네티스는 containerd, CRI-O같은 컨테이너 런타임 및 모든 Kubernetied CRI(컨테이너 런타임 인터페이스) 구현체를 지원한다

    애드온
    애드원은 쿠버네티스 리소스를 이용하여 클러스터 기능을 구현한다 이들은 클러스터 단위의 기능을 제공하기 때문에 애드온에 대한 네임스페이스에리소스는 kube-system
    네임스페이스에 속한다


    DNS 
    여타 애드온들이 절대적으로 요구되지 않지만 많은 예시에서 필요로 하기 때문에 모든 쿠버네티스 클러스터는 클러스터 DNS를 갖추어야만 한다
    클러스터 DNS는 구성환경 내 다른 DNS서버와 더불어 쿠버네티스 서비스를 위해 DNS레코드를 제공해주는 DNS서버다
    쿠버네티스에 의해 구동되는 컨테이너는 DNS검색에서 이 DNS서버를 자동으로 포함한다 

    웹 UI(대시보드)
    대시보드는 쿠버네티스 클러스터를 위한 범용의 웹 기반 UI다 사용자가 클러스터 자체뿐만 아니라 클러스터에서 동작하는 앱에 대한 관리와 문제해결을 할 수 있도록 해준다


    컨테이너 리소스 모니터링
    컨테이너 리로스 모니터링은 중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공해준다 

    클러스터 -레벨 로깅
    클러스터-레벨 로깅 메커니즘은 검색/열람 인터페이스와 함께 중앙 로그 저장소에 컨테이너 로그를 저장하는 책임을 진다 


    요약
    노드 컴포넌트는 파드를 유지하고 런타임 환경을 제공하며 모든 노드 상에서 동작한다
    kublet은 각 노드에서 실행되는 에이전트이며 파드에서 컨테이너가 확실하게 동작하게 한다 
    kube-proxy 는 노드에서 실행되는 네트워크 프록시로 네트워크 규칙을 유지 관리한다 
    컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어이다
    애드온은 쿠버네티스 리소스를 이용하여 클러스터 기능을 구현한다
    모든 쿠버네티스 클러스터는 클러스터 DNS를 갖추어야 한다 클러스터 DNS는 다른 DNS서버와 더불어 쿠버네티스 서비르를 위해 DNS레코드를 제공해주는 DNS서버다
    대시보드는 클러스터를 위한 웹 기반 UI이다
    컨테이너 리로스 모니터링은 중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시계열 매트릭스를 기록하고 그 데이터를 열람하기 위한 UI를 제공해준다 
    클러스터-레벨 로깅 메커니즘은 검색/열람 인터페이스와 함께 중앙 로그 저장소에 컨테이너 로그를 저장하는 책임을 진다 

    </노드 컴포넌트>


요약 
쿠버네티스를 배포하면 클러스터가 생기고 클러스터 밑에는 노드라고 하는 워커 머신이 있다 워커노드는 앱 구성 요소인 파드를 호스트한다 
컨트롤 플레인은 워커 노드와 파드를 관리한다 

</쿠버네티스 컴포넌트>



<쿠버네티스 API>

쿠버네티스 컨트롤 플레인의 핵심은 API서버이다 API서버는 최종 사용자 클러스터의 다른 부분 , 외부컴포넌트가 서로 통신할 수 있도록 HTTP API를 제공한다
쿠버네티스 API를 사용하면 쿠버네티스 API오브젝트(예: 파드 네임스페이스, 컨피그맵,이벤트 )를 질의하고 조작할 수 있다

대부분 작업은 kubectl 커멘드 라인 인터페이스 또는 API를 사용하는 kubeadm과 같은 다른 커멘드 라인 도구를 통해 수행할 수 있다 그러나 REST 호출을 사용하여
API에 접근할 수도 있다

쿠버네티스 API를 사용하여 앱을 작성하는경우 클라이언트 라이브러리중 하나를 사용하는 것이 좋다 

    <OPEN API 명세>


    OPEN API V2
    쿠버네티스 API서버는  /oepnapi/v2엔드포인트를 통해 통합된 OpenAPI v2스팩을 제공한다
    쿠버네티스는 주로 클러스터 내부 통신을 위해 대안적인 protobuf에 기반한 직렬화 형식을 구현한다 

    OPEN API V3
    쿠버네티스 v1.25버전은 OPENAPI v3 API발행에 대한 베타 지원을 제공한다 kube-apiserver구성요소에 OPENAPIV3기능 게이트를 비활성화하여 베타 기능을
    비활성화 할 수 있다 
    /openapi/v3 디스커버리 엔드포인트는 사용 가능한 모든 그룹/버전의 목록을 제공한다 이 엔드포인트는 JSON만을 반환한다 
    쿠버네티스 API 서버는 쿠버네티스 그룹 버전에 따른 OpenAPI v3 스펙을 /openapi/v3/apis/<group>/<version>?hash=<hash> 엔드포인트에 게시한다.


    </OPEN API 명세>


지속성 
쿠버네티스는 오브젝트의 직렬화된 상태를 etcd에 기록하여 저장한다

API그룹과 버전 규칙
필드를 쉽게 제거하거나 리소스 표현을 재구성하기 위해, 쿠버네티스는 각각 /api/v1 또는 
/apis/rbac.authorization.k8s.io/v1alpha1 과 같은 서로 다른 API 경로에서 여러 API 버전을 지원한다.

버전 규칙은 리소스나 필드 수준이 아닌 API 수준에서 수행되어 API가 시스템 리소스 및 동작에 대한 명확하고 
일관된 보기를 제공하고 수명 종료 및/또는 실험적 API에 대한 접근을 제어할 수 있도록 한다.

API 리소스는 API 그룹, 리소스 유형, 네임스페이스 (네임스페이스 리소스용) 및 이름으로 구분된다 서로 다른 모든 버전은 실제로 동일한 지속 데이터의 표현이다
 API 서버는 여러 API 버전을 통해 동일한 기본 데이터를 제공할 수 있다.


API 변경 사항
쿠버네티스 프로젝트는 기존 클라이언트와의 호환성을 깨지 않고 다른 프로젝트가 적응할 기회를 가질 수 있도록 장기간 해당 호환성을 유지하는 것을 목표로 한다.
일반적으로, 새 API 리소스와 새 리소스 필드는 자주 추가될 수 있다. 리소스 또는 필드를 제거하려면 API 지원 중단 정책을 따라야 한다
쿠버네티스는 일반적으로 API 버전 v1 에서 안정 버전(GA)에 도달하면, 공식 쿠버네티스 API에 대한 호환성 유지를 강력하게 이행한다. 또한, 쿠버네티스는 가능한 경우 베타 API 버전에서도 호환성을 유지한다.
베타 API를 채택하면 기능이 안정된 후에도 해당 API를 사용하여 클러스터와 계속 상호 작용할 수 있다.

</쿠버네티스 API>


<쿠버네티스 오브젝트 >
쿠버네티스 오브젝트는 영속성을 가지는 오브젝트이다. 클러스터의 상태를 나타내기 위해 이 오브젝트를 이용한다.

다음과 같이 기술 할 수 있다 
1.어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)
2.그 애플리케이션이 이용할 수 있는 리소스
3.그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책

오브젝트를 생성하게 되면, 쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 동작한다
생성이든, 수정이든, 또는 삭제든 쿠버네티스 오브젝트를 동작시키려면, 쿠버네티스 API를 이용해야 한다.
클라이언트 라이브러리 중 하나를 이용하여 여러분만의 프로그램에서 쿠버네티스 API를 직접 이용할 수도 있다


오브젝트 명세(spec)와 상태(status)
거의 모든 쿠버네티스 오브젝트는 오브젝트의 구성을 결정해주는 두 개의 중첩된 오브젝트 필드를 포함한다 
오브젝트 spec 과 오브젝트 status 인데 
spec을 가진 오브젝트는 오브젝트를 생성할 때 리소스에 원하는 특징(의도한 상태)에 대한 설명을 제공해서 설정한다.
status 는 쿠버네티스 시스템과 컴포넌트에 의해 제공되고 업데이트된 오브젝트의 현재 상태 를 설명한다.


</쿠버네티스 오브젝트 >



<쿠버네티스 오브젝트 관리 >
kubectl 커맨드라인 툴은 쿠버네티스 오브젝트를 생성하고 관리하기 위한 몇 가지 상이한 방법을 지원한다.

명령형 커맨드 
명령형 커맨드를 사용할 경우, 사용자는 클러스터 내 활성 오브젝트를 대상으로 직접 동작시킨다. 사용자는 실행할 작업을 인수 또는 플래그로 kubectl 커맨드에 지정한다.
일회성 작업에 좋다 
ex) kubectl create deployment nginx --image nginx

장점 
커멘드는 하나의 동작을 나타내는 단어로 표현
클러스터를 수정하기 위해 단 하나의 단계만 필요로

단점
변경 검토 프로세스와 통합되지 않는다.
변경에 대한 감사 추적을 제공하지 않는다
활성 동작 이외에는 레코드 소스를 제공하지 않는다
오브젝트 생성을 위한 템플릿을 제공하지 않는다 


명령형 오브젝트
구성은 kubectl커멘트로 작업, 선택적 플래그, 하나 이상으 파일 이름 파일은 YAML또는 JSON형식으로 오브젝트의 완전한 정의를 포함해야 한다 

장점 
구성은 GIT과 같은 곳에 보관가능
푸시와 감사 추적 전에 검토하는것과 같은 프로세스를 통합할 수 있다
새로운 오브젝트 생성을 위한 템플릿 제공
간결하고 이해가 쉬움
1.5버전부터 더 성숙한 명령형 오브젝트 구성 제공

단점
오브젝트 스키마에 대한 기본적인 이해 필요
YAML파일을 기록하는 추가적인 과정 필요
디렉터리가 아닌 파일에 적합
활성 오브젝트에 대한 업데이트는 구성 파일에 반영되어야 한다 그러지 않으면 교체 중에 손실된다 


선언형 오브젝트 
사용자는 로컬에 보관된 오브젝트 구성 파일을 대상으로 작동시키지만 사용자는 파일에서 수행할 작업을 정의하지 안흔ㄴ다
생성 업데이트 그리고 삭제는 kubectl에 의해 오브젝트마다 자동으로 감지된다 이를 통해 다른 오브젝트에 대해 다른 조작이 필요할 수 있는
디렉터리 작업을 할 수 있다

장점 
활성 오브젝트에 직접 작성된 변경 사항은 구성 파일로 다시 병합되지 않더라도 유지된다.
구성은 디렉터리에서의 작업 및 오브젝트 별 작업 유형(생성, 패치, 삭제)의 자동 감지에 더 나은 지원을 제공한다.

단점
선언형 오브젝트 구성은 예상치 못한  결과를 디버깅하고 이해하기 어렵다
diff를 사용한 부분 업데이트는 복잡한 병합 및 패치 작업을 일으킨다 


</쿠버네티스 오브젝트 관리 >



<오브젝트 이름과 ID>
각 오브젝트는 해당 유형의 리소스에 대해 고유한 이름을 가지고 있다 또한 모든 쿠버네티스 오브젝트는 전체 클러스터에 걸쳐 고유한 UID를 가지고 있다
ex) test인 파드는 동일한 네임스페이스 내에서 하나만 존재할 수 있지만 test인 파드와 디플로이먼트는 각각 존재할 수 있다

이름 
/api/v1/pods/some-name과 같이 리소스 URL에서 오브젝트를 가리키는 클라이언트 제공 문자열.

특정 시점에 같은 종류 내에서는 하나의 이름은 하나의 오브젝트에만 지정될 수 있다. 하지만
오브젝트를 삭제한 경우 삭제된 오브젝트와 같은 이름을 새로운 오브젝트에 지정 가능하다.


서브도메인 이름
253자를 넘지 말아야한다, 소문자 영숫자 - 또는 .만 가능하다 , 영숫자로 시작, 영숫자로 끝

RFC 1123레이블 이름 , RFC 1035 레이블 이름
최대 63자 , 소문자 영숫자 또는 -만 포함 , 영숫자로 시작, 영숫자로 끝

경로 세그먼트 이름
일부 리소스 유형에서는 이름을 경로 세그먼트로 안전하게 인코딩 할 수 있어야 한다
이름이 . 또는 ..이 아닐 수 있으며 이름에는 / 또는 %가 포함될 수 없다.

UID
오브젝트를 중복없이 식별하기 위해 시스템이 생성하는 문자열 
모든 오브젝트는 서로 구분되는 UID를 가진다 이는 기록상 유사한 오브젝트의 출현을 구분하기 위함



</오브젝트 이름과 ID>


<네임스페이스>
네임스페이스 는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다. 리소스의 이름은 네임스페이스 내에서 유일해야 하며
네임스페이스 간에서 유일할 필요는 없다 

여러개의 네임스페이스를 사용하는 경우 
네임스페이스는 팀이나 프로젝트에 걸쳐 많은 사용자가 있는 환경에서 사용되도록 만들어졌다
사용자가 거의 없으면 고려할 필요가 없다 필요할때만 사용
네임스페이스는 클러스터 자원을 여러 사용자에게 나누는 방법이다 
동일한 소프트웨어의 다른 버전과 같이 약간 다른 리소스를 분리하기 위해 여러 네임스페이스를 사용할 필요는 없다 동일한 네임스페이스에서
리소스를 구분하기 위해 레이블을 사용한다 

네임스페이스 조회
kubectl get namespace
쿠버네티스는 처음에 네 개의 초기 네임스페이스를 갖는다.
default - 다른 네임스페이스가 없는 오브젝트를 위한 기본 네임스페이스
kube-system  - 쿠버네티스 시스템에서 생성한 오브젝트를 위한 네임스페이스
kube-public  - 자동으로 생성되며 모든 사용자가 읽기 권한으로 접근할 수 있다. 주로 전체 클러스터 중에 공개적으로 드러나서 읽을
수 있는 리소스를 위해 예약되어 있다
kube-node-lease - 각 노드와 연관된 리스 오브젝트를 갖는다. 노드 리스는 kubelet이 하트비트를 보내서 컨트롤 플레인이 노드의 장애를 탐지할 수 있게 한다.

요청에 네임스페이스 설정
ex) kubectl run nginx --image=nginx -- namespace<=insert-namespace-name-here>

선호하는 네임스페이스 설정 
ex)kubectl config set-context --current --namespace=<insert-namespace-name-here> 이후 모든 kubectl명령애서 사용하는 네임스페이스를 컨텍스트에 영구 저장할 수 있다

네임스페이스와 DNS
서비스를 생성하면 해당 DNS 엔트리가 생성된다 엔트리는 <서비스-이름>.<네임스페이스-이름>.svc.cluster.local의 형식을 갖는다
컨테이너가 서비스-이름만 사용하면 네임스페이스 내에 국한된 서비스로 연결된다 개발,스테이싱,운영과 같이 여러 네임스페이스 내에서 
동일한 설정을 하는 경우 유용하다 네임스페이스를 넘어서 접근하기 위해서는 전체 주소 도메인 이름을 사용해야 한다 


모든 오브젝트가 네임스페이스에 속하지는 않는다
대부분은 네임스페이스에 속하지만 네임스페이스 리소스 자체는 네임스페이스에 속하지 않는다 그리고 노드나 퍼시스턴트 볼륨과 같은 저수준 리소스는 어느 네임스페이스에도
속하지 않는다

네임스페이스에 속하지 않는 쿠버네티스 리소스 조회
ex) kubectl api-resources --namespaced=false

자동 레이블링
쿠버네티스 컨트롤 플레인은 NamespaceDefaultLabelName 기능 게이트가 활성화된 경우 모든 네임스페이스에 변경할 
수 없는 레이블 kubernetes.io / metadata.name 을 설정한다. 레이블 값은 네임스페이스 이름이다

</네임스페이스>


인터넷 찾아보니까 노드에 쿠버네티스 적용하려면 도커파일을 생성하고 
도커 빌드 후 디플로이먼트 및 서비스 오브젝트 실행 후 쿠버네티스 클러스터에 배포하라고 되어있다